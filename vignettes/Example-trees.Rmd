---
title: "The quartet distance"
author: "Martin R. Smith"
date: "22 November 2017"
output: rmarkdown::html_document
bibliography: Example-trees.bib
csl: systematic-biology.csl
vignette: >
  %\VignetteIndexEntry{Example Trees}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r Initialize, include=FALSE}
require('ape')
require('SlowQuartet')
data('sq_trees')
n_tip <- 11
ref_tree <- sq_trees[[1]]
tip_colours <- Ternary::cbPalette15[-c(4, 7)] # Rm Tritanopia duplicates of 13 and 3
palette4 <- Ternary::cbPalette8[1:4]

rf_max <- (n_tip - 3) * 2

colplot <- function (tr, title=NULL, bold=NULL, ...) {
  tr$edge.length <- rep(1, dim(tr$edge)[1])
  font <- rep(1, length(tr$tip.label))
  if (!is.null(bold)) font[tr$tip.label %in% bold] <- 4
  plot(tr, tip.col=tip_colours[as.integer(tr$tip.label)], main=title, cex.main=0.8, font=font, y.lim=c(-3.5, n_tip), ...)
}

rfplot <- function (tr, title, highlight=NULL, ref=ref_tree, ...) {
  tree_dist <- phangorn::treedist(tr, ref)
  tree_pair <- lapply(list(tr, ref), ape::root, outgroup='1', resolve.root=FALSE)
  class(tree_pair) <- 'multiPhylo'
  topo_dist <- as.matrix(ape::dist.topo(tree_pair, method='PH85'))[2]
  
  colplot(tr, title, highlight, cex=0.8, ...)
  text_x <- par('usr')[2] * 0.5
  
  text(text_x, -0.5, 'Quartet:', cex=0.8, pos=2)
  text(text_x, -1.5, "RF:", cex=0.8, pos=2)
  text(text_x, -2.5, "Path:", cex=0.8, pos=2)
  text(text_x, -3.5, "SPR:", cex=0.8, pos=2)
  text(text_x, -0.5, paste0(choose(11, 4) - MatchingQuartets(list(tr, ref))[1, 2], '/', choose(11,4)), cex=0.8, pos=4)
  text(text_x, -1.5, paste0(topo_dist, '/', rf_max), cex=0.8, pos=4)
  text(text_x, -2.5, paste0(signif(tree_dist[2], 3)), cex=0.8, pos=4)
  text(text_x, -3.5, paste0(phangorn::sprdist(tr, ref)[1]), cex=0.8, pos=4)
}

polyplot <- function (tr, title, highlight, ...) {
  tree_pair <- lapply(list(ref_tree, tr), ape::unroot)
  class(tree_pair) <- 'multiPhylo'
  partitions <- MatchingSplits(tree_pair)[, 2]
  
  colplot(tr, title, highlight, ...)
  x_mid <- par('usr')[2] * 0.62
  
  text(x_mid, -0.5, cex=0.8, pos=2, "Quartets contradicted")
  text(x_mid, -1.5, cex=0.8, pos=2, "Quartets unresolved")
  text(x_mid, -2.5, cex=0.8, pos=2, "Partitions contradicted")
  text(x_mid, -3.5, cex=0.8, pos=2, "Partitions unresolved")
  
  text(x_mid, -0.5, cex=0.8, pos=4, paste0(choose(11, 4) - sum(MatchingQuartets(list(tr, ref_tree))[, 2]), '/', choose(11,4)))
  text(x_mid, -1.5, cex=0.8, pos=4, paste0(MatchingQuartets(list(tr, ref_tree))[2, 2], '/', choose(11,4)))
  # The below assumes that ref is bifurcated, so if a partition's in cf not ref it must contradict.
  text(x_mid, -2.5, cex=0.8, pos=4, paste0(partitions['cf_not_ref'], '/', rf_max / 2))
  text(x_mid, -3.5, cex=0.8, pos=4, paste0(partitions['ref_not_cf'] - partitions['cf_not_ref'], '/', rf_max / 2)) 
}

#par(mfrow=c(3,5), mar=rep(1.2, 4), cex.main=2/3, cex=0.9)
#for (i in seq_along(sq_trees)) colplot(sq_trees[[i]], names(sq_trees)[i])

```

## Tree distance metrics

A number of metrics area available to quantify the similarity between two undirected
topologies (i.e. unrooted trees with no edge lengths).

### Partition metric
The Robinson-Foulds (RF, 'partition' or 'symmetric difference') metric [@Robinson1981; @Steel1993]
adds the number of bipartitions that are present in tree A (but not tree B)
to the number of bipartitions present in tree B (but not tree A).  

It is most useful when the trees to be compared are very similar; it has
a low range of integer values, limiting its ability to distinguish between
trees [@Steel1993].

### SPR metric
The subtree pruning and regrafting (SPR) distance [@Penny1985] counts the 
number of SPR rearrangements necessary to transform Tree A into Tree B.

### Path difference metric
The length of a path from one tip to another in a tree is the number of edges
within the tree that must be crossed to navigate from one tip to the other.

Given two trees, is possible to calculate the difference in path length between
each pair of tips.

The path difference metric [@Steel1993] is the square root of the sum of squares
of each of these differences.

### Quartet metric
The quartet metric [@Estabrook1985] counts what proportion of four-taxon statements 
are true in both trees.

For any four tips A, B, C and D, a bipartition on a bifurcating tree will separate
tip A and either B, C or D from the other two tips.  That is to say, removing
all other tips from the tree will leave one of these three trees:

```{R Three four-taxon trees, echo=FALSE, fig.height=2, fig.width=6}
par(mfrow=c(1, 3), mar=c(0.5, 1, 0.5, 1), cex=1)
plot(ape::read.tree(text='((A, B), (C, D));'), tip.color=Ternary::cbPalette8[c(1, 4, 7, 5)], font=2)
plot(ape::read.tree(text='((A, C), (B, D));'), tip.color=Ternary::cbPalette8[c(1, 7, 4, 5)], font=2)
plot(ape::read.tree(text='((A, D), (C, B));'), tip.color=Ternary::cbPalette8[c(1, 5, 7, 4)], font=2)
```

Thus two of the random trees below share the quartet `(A, B), (C, D)`, whereas 
the third does not; these four tips are divided into `(A, D), (B, C)`.

```{R Plot a quartet, fig.height=2, fig.width=6, echo=FALSE}
par(mfrow=c(1, 3))
set.seed(7)
trees7 <- lapply(logical(3), function (X) {
    tr <- ape::rtree(7, br=NULL)
    tr$edge.length <- rep(1, 12)
    tr$tip.label <- LETTERS[1:7]
    tr
  })
PlotQuartet(trees7, LETTERS[1:4], cex=1.4, font=2)
```

There are $n\choose4$ groups of four taxa in a tree with $n$ tips;
for each of these groups, one of the three trees above will be consistent with
a given tree.  As such, two identical trees will have a quartet distance of
0, and a random pair of trees will have an expected quartet distance of 
${n\choose{4}} / 3$. Because quartets are not independent of one another,
no pair of trees with six or more tips can have a quartet distance of
$n\choose4$ [@Steel1993].

## Desired behaviour of tree distance metrics

The advantages of the Quartet distance [@Estabrook1985] over other tree distance
metrics [@Penny1985] are best illustrated by examining a set of example trees.

### Moving a single taxon

If trees differ only in the location of a single taxon, then the distance between
two trees should correspond to the distance that this taxon has been moved.

```{R Moving a single taxon, fig.height=3, fig.width=12, echo=FALSE}
par(mfrow=c(1, 4), mar=rep(0.4, 4), cex=1)
colplot(ref_tree,     'Reference tree', 1)
rfplot(sq_trees$move_one_near, 'Short move', 1)
rfplot(sq_trees$move_one_mid, 'Medium move', 1)
rfplot(sq_trees$move_one_far,   'Long move', 1)
```

The subtree pruning and regrafting (SPR) distance [@Penny1985] does not distinguish
between these trees, as they differ only in the placement of a single tip.
The Robinson-Foulds (RF, 'partition' or 'symmetric') [@Robinson1981],
path difference [@Steel1993] and quartet [@Estabrook1985] metrics, 
in contrast, recognize trees in which this tip has been 
moved further as more distant from the starting tree.

### Moving two taxa

Intuitively, moving a pair of tips on a tree should lead to higher tree distances
than moving a single tip.  In the case of a short move, the RF distance
does not differ whether one or two tips are moved.
For larger moves, however, the RF distance is _less_ when two tips are moved than
when a single tip is moved.  The path and quartet metrics perform as expected.

```{R Moving a cherry, fig.height=8, fig.width=9, echo=FALSE}
par(mfrow=c(3, 3), mar=c(2.4, 0.4, 0.4, 0.4), cex=1)

colplot(ref_tree, 'Reference tree')
rfplot(sq_trees$move_one_near, 'Short move 1', 1)
rfplot(sq_trees$move_two_near, 'Short move 2', 10:11)

colplot(ref_tree, 'Reference tree')
rfplot(sq_trees$move_one_mid, 'Medium move 1', 1)
rfplot(sq_trees$move_two_mid, 'Medium move 2', 10:11)

colplot(ref_tree, 'Reference tree')
rfplot(sq_trees$move_one_far,   'Long move 1', 1)
rfplot(sq_trees$move_two_far,   'Long move 2', 10:11)

```

### Maximum distance
A distance metric should distinguish slightly-perturbed trees from
random trees and those that are more different from the starting tree than 
expected by chance.

The worst-case scenario for the Robinson-Foulds metric involves the relocation
of a single taxon in a pectinate tree. As there are no partitions 
shared between the two trees, this situation generates the maximum
RF distance, and this trivially deformed tree is considered to be as distant
as a random tree.

```{R Pectinate to break RF, fig.height=3, fig.width=9, echo=FALSE}
par(mfrow=c(1, 3), mar=rep(0.4, 4), cex=1)

pectinate_tree  <- ape::read.tree(text='(1, (2, (3, (4, (5, (6, (7, (8, (9, (10, 11))))))))));')
pectinate_unrooted <- ape::unroot(pectinate_tree)
pectinate_move1 <- ape::read.tree(text='(2, (3, (4, (5, (6, (7, (8, (9, (10, (11, 1))))))))));')
colplot(pectinate_tree, 'Pectinate tree')
rfplot(pectinate_move1,  'Move one taxon', 1, ref=pectinate_unrooted)
rfplot(sq_trees$random_tree,   'Random tree',   1, ref=pectinate_unrooted)
```

An advantage of the Quartet distance is that the normalized metric of a random
tree is $2/3$ [@Day1986, @Steel1993].  As such, trees that are more different than expected by chance
can be readily recognized, as their quartet distance will be greater than 
`r choose(n_tip, 4) * 2 / 3`/`r choose(n_tip, 4)`:

```{R Increasing distances, fig.height=3, fig.width=9, echo=FALSE}
par(mfrow=c(1, 3), mar=rep(0.4, 4), cex=1)
colplot(ref_tree, 'Reference tree')
rfplot(sq_trees$random_tree,   'Random tree'     )
rfplot(sq_trees$opposite_tree, 'Maximum distance')
```

### Unresolved trees

Whereas the path distance and SPR metrics are only defined on bifurcating trees,
the quartet approach can be applied to trees that contain polytomies -- i.e. 
not every node is resolved as bifurcating.


Estabrook _et al_. [,@Estabrook1985] propose four measures of quartet distance to 
be applied where one or both trees contain polytomies, each of which evaluate
to the quartet distance if both trees are bifurcating.

For each of the $Q$ possible quartets for trees that contain $n$ taxa, in two trees, there are five possibilities [@Estabrook1985]:

If resolved in both trees:
 1. **S**ame ($s$)
 2. **D**ifferent ($d$)
 
Otherwise:
 3. Resolved in **T**ree **1** only ($r_1$)
 4. Resolved in **T**ree **2** only ($r_2$)
 5. **U**nresolved in both trees ($u$)

Various assemblies of these measures provide four quartet measures for 
trees that contain polytomies:

#### DNC: Do not conflict
$(Q - d) / Q$
Number of quartets that do not conflict 

#### EA: Explicitly Agree
$s / Q$
Count of number of resolved quartets occurring in both trees 

#### SJA: Strict Joint Assertions
$s / (s + d)$
Of the quartets that are resolved on both trees, what proportion agree?

#### SSJA: Semi-strict Joint Assertions
$(s + u) / (s + d + u)$
Of the quartets that are either resolved or unresolved on both trees, what
proportion do not conflict?

None of these measures is clearly appropriate in all cases. 

I propose a fifth, which is analogous to both the partition metric and the 
Kullback-Leiber divergence: it measures the amount of information
that must be supplied to change one tree into the other.

Here, a resolved quartet represents a single unit of information; to navigate 
from one tree to another, one requires a list of quartets that must be 'unpicked',
comprising the $d$ different quartets and the $t_1$ that are present only in
the starting tree, and a list of quartets that must be forged, comprising the
$d$ different quartets (which, having been removed, must now be added in their
correct configuration) and the $t_2 quartets that are resolved only on the second
tree.  Normalizing this count gives:

#### Quartet divergence
$Q - ((2d + r_1 + r_2) / 2Q)$

In bifurcating trees, this measure is identical to those proposed by Estabrook
_et al_. [,@Estabrook1985].  Because quartets are not independent of one another,
the term "information" is not equivalent to the Shannon entropy.


```{R Polytomies - same topology, fig.height=3, fig.width=9, echo=FALSE}
par(mfrow=c(1, 3), mar=c(0.4, 0.4, 0.4, 0.4), cex=1)

colplot(ref_tree, 'Reference tree')
polyplot(sq_trees$collapse_one, 'One polytomy', 7:9)
polyplot(sq_trees$collapse_some, 'Much polytomy', 1:9)

```

In the above case, the underlying topology was unchanged.  We can also change
the topology -- here we have the same loss of resolution with the trees
in which one taxon (1) was moved:

```{R Polytomies 1, fig.height=3, fig.width=9, echo=FALSE}
par(mfrow=c(1, 3), mar=c(0.4, 0.4, 0.4, 0.4), cex=1)

polyplot(sq_trees$move_one_mid, 'One moved, no polytomy', 1)
polyplot(sq_trees$m1mid_col1, 'One moved, one polytomy', 1)
polyplot(sq_trees$m1mid_colsome, 'One moved, much polytomy', 1)

```

And here again, collapsing nodes in the trees
in which two taxa (10 & 11) were moved:

```{R Polytomies 2, fig.height=3, fig.width=9, echo=FALSE}
par(mfrow=c(1, 3), mar=c(0.4, 0.4, 0.4, 0.4), cex=1)

polyplot(sq_trees$move_two_mid,  'Two moved, no polytomy'  , 10:11)
polyplot(sq_trees$m2mid_col1,    'Two moved, one polytomy' , 10:11)
polyplot(sq_trees$m2mid_colsome, 'Two moved, much polytomy', 10:11)

```

## Plotting this data

We can visualize this data using a ternary diagram.

```{R Plot some trees, fig.width=10, fig.height=5, echo=FALSE}
library('Ternary')
par(mfrow=c(1, 2), mar=rep(0.3, 4))
collapse_perfect <- c('ref_tree', 'collapse_one', 'collapse_some')
collapse_move1   <- c('move_one_mid', 'm1mid_col1', 'm1mid_colsome')
collapse_move2   <- c('move_two_mid', 'm2mid_col1', 'm2mid_colsome')

TernaryPlot(' Consistent', ' Contradicted', 'Unresolved', lab.cex=0.8, lab.font=2,
            grid.lty='solid', col=rgb(0.9, 0.9, 0.9), grid.col='white', 
            axis.col=rgb(0.6, 0.6, 0.6), ticks.col=rgb(0.6, 0.6, 0.6),
            padding=0.1)
title(main="\r\nQuartet distances", cex.main=0.8)
HorizontalGrid()
AddToTernary(lines, list(c(1/3, 2/3, 0), c(0, 0, 1)), lty='dotted', col=cbPalette8[8], lwd=2)

pchs <- c(1, 4, 3)
quartet_distances <- QuartetPoints(sq_trees)
TernaryPoints(quartet_distances[collapse_perfect, ], col=cbPalette8[2], pch=pchs, cex=1.5)
TernaryLines (quartet_distances[collapse_perfect, ], col=cbPalette8[2])
TernaryPoints(quartet_distances[collapse_move1, ],   col=cbPalette8[3], pch=pchs, cex=1.5)
TernaryLines (quartet_distances[collapse_move1, ],   col=cbPalette8[3])
TernaryPoints(quartet_distances[collapse_move2, ],   col=cbPalette8[4], pch=pchs, cex=1.5)
TernaryLines (quartet_distances[collapse_move2, ],   col=cbPalette8[4])
legend('bottomright', 
       lty=rep('dotted', 2),
       lwd=c(1, 2),
       col=c('grey', cbPalette8[8]),
       legend=c('Divergence contours', 'Distance of random tree'), 
       cex=0.8, bty='n')
arrows(sqrt(3/4) * 0.5, 0.5, sqrt(3/4) * 0.8, 0.5, length=0.1)
text  (sqrt(3/4) * 0.65, 0.5, pos=3, 'Decreasing resolution', cex=0.8)

arrows(sqrt(3/4) * 0.98, 0.40, sqrt(3/4) * 0.98, 0.20, length=0.1)
text  (sqrt(3/4) * 1.01, 0.30, pos=3, 'Increasing divergence', cex=0.8, srt=270)

TernaryPlot(' Consistent', ' Contradicted', 'Unresolved', lab.cex=0.8,
            grid.lty='solid', col=rgb(0.9, 0.9, 0.9), grid.col='white', 
            axis.col=rgb(0.6, 0.6, 0.6), ticks.col=rgb(0.6, 0.6, 0.6),
            padding=0.1)
title(main="\r\nPartition distances", cex.main=0.8)
HorizontalGrid()
partition_distances <- SplitsPoints(sq_trees)
TernaryPoints(partition_distances[collapse_perfect, ], col=cbPalette8[2], pch=pchs, cex=1.5)
TernaryLines (partition_distances[collapse_perfect, ], col=cbPalette8[2])
TernaryPoints(partition_distances[collapse_move1, ],   col=cbPalette8[3], pch=pchs, cex=1.5)
TernaryLines (partition_distances[collapse_move1, ],   col=cbPalette8[3])
TernaryPoints(partition_distances[collapse_move2, ],   col=cbPalette8[4], pch=pchs, cex=1.5)
TernaryLines (partition_distances[collapse_move2, ],   col=cbPalette8[4])
legend('topright', cex=0.8, bty='n',
       pch=pchs, pt.cex=1.5,
       title='Collapse:',
       legend=c('No nodes', 'One node', 'Many nodes'))
legend('bottomright', cex=0.8, bty='n',
       pch=20, pt.cex=1.5, col=cbPalette8[2:4],
       title='Move:', legend=c('No tips', 'One tip', 'Two tips'))


```

It is sometimes of interest to establish which of a selection of trees is most 
instructive about the reference tree.  How this might be done is not
necessarily intuitive: there is often a tension between accuracy and precision.
That is to say, should a tree that is perfectly accurate but poorly resolved be
preferred to a tree that is partially inaccurate but completely resolved?

One approach to this trade-off is to seek the tree of minimum entropy: that is,
the tree that diverges least  from the reference
tree.

A tree that is perfectly resolved, yet contains some incorrect nodes, delivers 
more information -- but also more misinformation -- than a poorly-resolved (yet
accurate) tree. The Kullback-Leibler divergence is the sum of the information
that is present in the reference tree, but not the candidate tree, plus the 
(mis)information that is present in the candidate tree but not the reference tree.

Put simply, to get from the candidate tree to the reference tree, one must be told
which groupings in the candidate tree are incorrect, and which groupings should be 
added in their place.

In the above instances, adding the number of quartets or partitions present in 
one but not both of the reference and candidate trees generates a measure analogous
to the Kullback-Leibler divergence.
The measure is only analogous because neither the number of 
quartets nor the number of partitions corresponds to a specific quantity of
information / entropy.  

Counting only the number of partitions fails to capture the fact that 
different partitions have different inherent information contents. 
A partition separating taxa  into two evenly-sized bipartitions is consistent 
with fewer trees than a partition separating two taxa from all others, thus has
a higher (Shannon) information content.

In contrast, each quartet specifies that one of three possibilities exists on a 
tree, so every quartet statement has the same information content: one trit (= 
$log(3) / log(2)$ bits).  The problem is that quartet statements (and partition
statements) are not independent from one another, meaning that the quartet 
metric is at best a rough approximation of the Kullback-Leibler divergence.

This important caveat notwithstanding, the quartet distance provides a promising
(if not statistically satisfying) approach to measuring the divergence between
two separate trees.  On the ternary diagrams presented above, points of equal 
divergence are connected by horizontal lines:  That is to say, any tree on a given 
contour is equally informative about the reference tree.

## Conclusion

The quartet divergence is the only available metric of tree distance that fullfils 
all of the following desiderata:

 - Allocates trees higher distances if a clade moves greater distances
 - Allocates trees higher distances if a the clade that is moved is larger
 - Distinguishes contradicted from unresolved information in trees that 
   are not fully bifurcating (resolved)
 - Identifies pairs of trees that are more random than expected by chance
 - Does not reach its maximum value after relatively trivial rearrangements
 
 The quartet divergence is proposed as a measure of how similar two trees are,
 taking into account the inevitable trade-off between precision and accuracy.

## References
